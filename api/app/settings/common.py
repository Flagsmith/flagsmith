"""
Django settings for app project.

Generated by 'django-admin startproject' using Django 1.9.

For more information on this file, see
https://docs.djangoproject.com/en/1.9/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/1.9/ref/settings/
"""

import importlib
import json
import os
import sys
import warnings
from datetime import datetime, timedelta
from importlib import reload

import dj_database_url
import pytz
from corsheaders.defaults import default_headers
from django.core.exceptions import ImproperlyConfigured
from django.core.management.utils import get_random_secret_key
from environs import Env
from task_processor.task_run_method import TaskRunMethod

from app.routers import ReplicaReadStrategy

env = Env()

# Build paths inside the project like this: os.path.join(BASE_DIR, ...)
BASE_DIR = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
PROJECT_ROOT = os.path.abspath(os.path.dirname(__file__))

ENV = env("ENVIRONMENT", default="local")
if ENV not in ("local", "dev", "staging", "production"):
    warnings.warn(
        "ENVIRONMENT env variable must be one of local, dev, staging, production"
    )

DEBUG = env.bool("DEBUG", default=False)

ADMINS = []
MANAGERS = []

# Enables the sending of telemetry data to the central Flagsmith API for usage tracking
ENABLE_TELEMETRY = env.bool("ENABLE_TELEMETRY", default=True)

# Enables gzip compression
ENABLE_GZIP_COMPRESSION = env.bool("ENABLE_GZIP_COMPRESSION", default=False)

SECRET_KEY = env("DJANGO_SECRET_KEY", default=get_random_secret_key())

HOSTED_SEATS_LIMIT = env.int("HOSTED_SEATS_LIMIT", default=0)

MAX_PROJECTS_IN_FREE_PLAN = 1


ALLOWED_HOSTS = env.list("DJANGO_ALLOWED_HOSTS", default=[])
USE_X_FORWARDED_HOST = env.bool("USE_X_FORWARDED_HOST", default=False)


CSRF_TRUSTED_ORIGINS = env.list("DJANGO_CSRF_TRUSTED_ORIGINS", default=[])

INTERNAL_IPS = ["127.0.0.1"]

if sys.version[0] == "2":
    reload(sys)
    sys.setdefaultencoding("utf-8")

# Application definition

INSTALLED_APPS = [
    "core.custom_admin.apps.CustomAdminConfig",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    "django.contrib.humanize",
    "rest_framework",
    "rest_framework.authtoken",
    # Used for managing api keys
    "rest_framework_api_key",
    "rest_framework_simplejwt.token_blacklist",
    "djoser",
    "django.contrib.sites",
    "custom_auth",
    "admin_sso",
    "api",
    "core",
    "corsheaders",
    "users",
    "organisations",
    "organisations.invites",
    "organisations.permissions",
    "projects",
    "sales_dashboard",
    "edge_api",
    "environments",
    "environments.permissions",
    "environments.identities",
    "environments.identities.traits",
    "features",
    "features.import_export",
    "features.multivariate",
    "features.versioning",
    "features.workflows.core",
    "segments",
    "app",
    "e2etests",
    "simple_history",
    "drf_yasg",
    "audit",
    "permissions",
    "projects.tags",
    "api_keys",
    "features.feature_external_resources",
    # 2FA
    "custom_auth.mfa.trench",
    # health check plugins
    "health_check",
    "health_check.db",
    "health_check.contrib.migrations",
    # Used for ordering models (e.g. FeatureSegment)
    "ordered_model",
    # Third party integrations
    "integrations.datadog",
    "integrations.amplitude",
    "integrations.sentry",
    "integrations.new_relic",
    "integrations.segment",
    "integrations.heap",
    "integrations.mixpanel",
    "integrations.rudderstack",
    "integrations.slack",
    "integrations.webhook",
    "integrations.dynatrace",
    "integrations.flagsmith",
    "integrations.launch_darkly",
    "integrations.github",
    "integrations.grafana",
    # Rate limiting admin endpoints
    "axes",
    "telemetry",
    # for filtering querysets on viewsets
    "django_filters",
    "import_export",
    "task_processor",
    "softdelete",
    "metadata",
    "app_analytics",
]

SILENCED_SYSTEM_CHECKS = ["axes.W002"]

SITE_ID = 1

db_conn_max_age = env.int("DJANGO_DB_CONN_MAX_AGE", 60)
DJANGO_DB_CONN_MAX_AGE = None if db_conn_max_age == -1 else db_conn_max_age

DATABASE_ROUTERS = ["app.routers.PrimaryReplicaRouter"]
NUM_DB_REPLICAS = 0
NUM_CROSS_REGION_DB_REPLICAS = 0
# Allows collectstatic to run without a database, mainly for Docker builds to collectstatic at build time
if "DATABASE_URL" in os.environ:
    DATABASES = {
        "default": dj_database_url.parse(
            env("DATABASE_URL"), conn_max_age=DJANGO_DB_CONN_MAX_AGE
        ),
    }
    REPLICA_DATABASE_URLS_DELIMITER = env("REPLICA_DATABASE_URLS_DELIMITER", ",")
    REPLICA_DATABASE_URLS = env.list(
        "REPLICA_DATABASE_URLS", default=[], delimiter=REPLICA_DATABASE_URLS_DELIMITER
    )
    NUM_DB_REPLICAS = len(REPLICA_DATABASE_URLS)

    # Cross region replica databases are used as fallbacks if the
    # primary replica set becomes unavailable.
    CROSS_REGION_REPLICA_DATABASE_URLS_DELIMITER = env(
        "CROSS_REGION_REPLICA_DATABASE_URLS_DELIMITER", ","
    )
    CROSS_REGION_REPLICA_DATABASE_URLS = env.list(
        "CROSS_REGION_REPLICA_DATABASE_URLS",
        default=[],
        delimiter=CROSS_REGION_REPLICA_DATABASE_URLS_DELIMITER,
    )
    NUM_CROSS_REGION_DB_REPLICAS = len(CROSS_REGION_REPLICA_DATABASE_URLS)

    # DISTRIBUTED spreads the load out across replicas while
    # SEQUENTIAL only falls back once the first replica connection is faulty
    REPLICA_READ_STRATEGY = env.enum(
        "REPLICA_READ_STRATEGY",
        type=ReplicaReadStrategy,
        default=ReplicaReadStrategy.DISTRIBUTED.value,
    )

    for i, db_url in enumerate(REPLICA_DATABASE_URLS, start=1):
        DATABASES[f"replica_{i}"] = dj_database_url.parse(
            db_url, conn_max_age=DJANGO_DB_CONN_MAX_AGE
        )

    for i, db_url in enumerate(CROSS_REGION_REPLICA_DATABASE_URLS, start=1):
        DATABASES[f"cross_region_replica_{i}"] = dj_database_url.parse(
            db_url, conn_max_age=DJANGO_DB_CONN_MAX_AGE
        )

    if "ANALYTICS_DATABASE_URL" in os.environ:
        DATABASES["analytics"] = dj_database_url.parse(
            env("ANALYTICS_DATABASE_URL"), conn_max_age=DJANGO_DB_CONN_MAX_AGE
        )
        DATABASE_ROUTERS.insert(0, "app.routers.AnalyticsRouter")
elif "DJANGO_DB_NAME" in os.environ:
    # If there is no DATABASE_URL configured, check for old style DB config parameters
    DATABASES = {
        "default": {
            "ENGINE": "django.db.backends.postgresql",
            "NAME": os.environ["DJANGO_DB_NAME"],
            "USER": os.environ["DJANGO_DB_USER"],
            "PASSWORD": os.environ["DJANGO_DB_PASSWORD"],
            "HOST": os.environ["DJANGO_DB_HOST"],
            "PORT": os.environ["DJANGO_DB_PORT"],
            "CONN_MAX_AGE": DJANGO_DB_CONN_MAX_AGE,
        },
    }
    if "DJANGO_DB_NAME_ANALYTICS" in os.environ:
        DATABASES["analytics"] = {
            "ENGINE": "django.db.backends.postgresql",
            "NAME": os.environ["DJANGO_DB_NAME_ANALYTICS"],
            "USER": os.environ["DJANGO_DB_USER_ANALYTICS"],
            "PASSWORD": os.environ["DJANGO_DB_PASSWORD_ANALYTICS"],
            "HOST": os.environ["DJANGO_DB_HOST_ANALYTICS"],
            "PORT": os.environ["DJANGO_DB_PORT_ANALYTICS"],
            "CONN_MAX_AGE": DJANGO_DB_CONN_MAX_AGE,
        }

        DATABASE_ROUTERS.insert(0, "app.routers.AnalyticsRouter")

LOGIN_THROTTLE_RATE = env("LOGIN_THROTTLE_RATE", "20/min")
SIGNUP_THROTTLE_RATE = env("SIGNUP_THROTTLE_RATE", "10000/min")
USER_THROTTLE_RATE = env("USER_THROTTLE_RATE", "500/min")
DEFAULT_THROTTLE_CLASSES = env.list("DEFAULT_THROTTLE_CLASSES", default=[])
REST_FRAMEWORK = {
    "DEFAULT_PERMISSION_CLASSES": ["rest_framework.permissions.IsAuthenticated"],
    "DEFAULT_AUTHENTICATION_CLASSES": (
        "custom_auth.jwt_cookie.authentication.JWTCookieAuthentication",
        "rest_framework.authentication.TokenAuthentication",
        "api_keys.authentication.MasterAPIKeyAuthentication",
    ),
    "PAGE_SIZE": 10,
    "UNICODE_JSON": False,
    "DEFAULT_PAGINATION_CLASS": "rest_framework.pagination.PageNumberPagination",
    "DEFAULT_THROTTLE_CLASSES": DEFAULT_THROTTLE_CLASSES,
    "DEFAULT_THROTTLE_RATES": {
        "login": LOGIN_THROTTLE_RATE,
        "signup": SIGNUP_THROTTLE_RATE,
        "mfa_code": "5/min",
        "invite": "10/min",
        "user": USER_THROTTLE_RATE,
    },
    "DEFAULT_FILTER_BACKENDS": ["django_filters.rest_framework.DjangoFilterBackend"],
    "DEFAULT_RENDERER_CLASSES": [
        "util.renderers.PydanticJSONRenderer",
        "rest_framework.renderers.BrowsableAPIRenderer",
    ],
}
MIDDLEWARE = [
    "django.middleware.security.SecurityMiddleware",
    "whitenoise.middleware.WhiteNoiseMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "corsheaders.middleware.CorsMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
    "simple_history.middleware.HistoryRequestMiddleware",
]

ADD_NEVER_CACHE_HEADERS = env.bool("ADD_NEVER_CACHE_HEADERS", True)
if ADD_NEVER_CACHE_HEADERS:
    MIDDLEWARE.append("core.middleware.cache_control.NeverCacheMiddleware")

APPLICATION_INSIGHTS_CONNECTION_STRING = env.str(
    "APPLICATION_INSIGHTS_CONNECTION_STRING", default=None
)
OPENCENSUS_SAMPLING_RATE = env.float("OPENCENSUS_SAMPLING_RATE", 1.0)

if APPLICATION_INSIGHTS_CONNECTION_STRING:
    MIDDLEWARE.insert(
        0, "integrations.opencensus.middleware.OpenCensusDbTraceMiddleware"
    )
    MIDDLEWARE.insert(0, "opencensus.ext.django.middleware.OpencensusMiddleware")
    OPENCENSUS = {
        "TRACE": {
            "SAMPLER": f"opencensus.trace.samplers.ProbabilitySampler(rate={OPENCENSUS_SAMPLING_RATE})",
            "EXPORTER": f"""opencensus.ext.azure.trace_exporter.AzureExporter(
                connection_string='{APPLICATION_INSIGHTS_CONNECTION_STRING}',
            )""",
        }
    }

if ENABLE_GZIP_COMPRESSION:
    # ref: https://docs.djangoproject.com/en/2.2/ref/middleware/#middleware-ordering
    MIDDLEWARE.insert(1, "django.middleware.gzip.GZipMiddleware")

# Google Analytics Configuration
GOOGLE_ANALYTICS_KEY = env("GOOGLE_ANALYTICS_KEY", default="")
GOOGLE_SERVICE_ACCOUNT = env("GOOGLE_SERVICE_ACCOUNT", default=None)
GA_TABLE_ID = env("GA_TABLE_ID", default=None)

if GOOGLE_ANALYTICS_KEY:
    MIDDLEWARE.append("app_analytics.middleware.GoogleAnalyticsMiddleware")

# Influx configuration
INFLUXDB_TOKEN = env.str("INFLUXDB_TOKEN", default="")
INFLUXDB_BUCKET = env.str("INFLUXDB_BUCKET", default="")
INFLUXDB_URL = env.str("INFLUXDB_URL", default="")
INFLUXDB_ORG = env.str("INFLUXDB_ORG", default="")

USE_POSTGRES_FOR_ANALYTICS = env.bool("USE_POSTGRES_FOR_ANALYTICS", default=False)
USE_CACHE_FOR_USAGE_DATA = env.bool("USE_CACHE_FOR_USAGE_DATA", default=False)
PG_API_USAGE_CACHE_SECONDS = env.int("PG_API_USAGE_CACHE_SECONDS", default=60)

FEATURE_EVALUATION_CACHE_SECONDS = env.int(
    "FEATURE_EVALUATION_CACHE_SECONDS", default=60
)

ENABLE_API_USAGE_TRACKING = env.bool("ENABLE_API_USAGE_TRACKING", default=True)

if ENABLE_API_USAGE_TRACKING:
    # NOTE: Because we use Postgres for analytics data in staging and Influx for tracking SSE data,
    # we need to support setting the influx configuration alongside using postgres for analytics.
    if USE_POSTGRES_FOR_ANALYTICS:
        MIDDLEWARE.append("app_analytics.middleware.APIUsageMiddleware")
    elif INFLUXDB_TOKEN:
        MIDDLEWARE.append("app_analytics.middleware.InfluxDBMiddleware")


ALLOWED_ADMIN_IP_ADDRESSES = env.list("ALLOWED_ADMIN_IP_ADDRESSES", default=list())
if len(ALLOWED_ADMIN_IP_ADDRESSES) > 0:
    warnings.warn(
        "Restricting access to the admin site for ip addresses %s"
        % ", ".join(ALLOWED_ADMIN_IP_ADDRESSES)
    )
    MIDDLEWARE.append("core.middleware.admin.AdminWhitelistMiddleware")

ROOT_URLCONF = "app.urls"

TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": ["templates"],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.debug",
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
            ],
        },
    },
]

WSGI_APPLICATION = "app.wsgi.application"

# Password validation
# https://docs.djangoproject.com/en/1.9/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        "NAME": "django.contrib.auth.password_validation.UserAttributeSimilarityValidator",
    },
    {"NAME": "django.contrib.auth.password_validation.MinimumLengthValidator"},
    {"NAME": "django.contrib.auth.password_validation.CommonPasswordValidator"},
    {"NAME": "django.contrib.auth.password_validation.NumericPasswordValidator"},
]

AUTHENTICATION_BACKENDS = [
    "admin_sso.auth.DjangoSSOAuthBackend",
    "django.contrib.auth.backends.ModelBackend",
]

DJANGO_ADMIN_SSO_OAUTH_CLIENT_ID = env.str("OAUTH_CLIENT_ID", default="")
DJANGO_ADMIN_SSO_OAUTH_CLIENT_SECRET = env.str("OAUTH_CLIENT_SECRET", default="")

# Internationalization
# https://docs.djangoproject.com/en/1.9/topics/i18n/

LANGUAGE_CODE = "en-us"

TIME_ZONE = "UTC"

USE_I18N = True

USE_L10N = True

USE_TZ = True

# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/1.9/howto/static-files/

STATIC_URL = "/static/"
STATIC_ROOT = os.path.join(PROJECT_ROOT, "../../static/")

MEDIA_URL = "/media/"  # unused but needs to be different from STATIC_URL in django 3

DEFAULT_FROM_EMAIL = env("SENDER_EMAIL", default="noreply@flagsmith.com")
EMAIL_CONFIGURATION = {
    # Invitations with name is anticipated to take two arguments. The persons name and the
    # organisation name they are invited to.
    "INVITE_SUBJECT_WITH_NAME": "%s has invited you to join the organisation '%s' on Flagsmith",
    # Invitations without a name is anticipated to take one arguments. The organisation name they
    # are invited to.
    "INVITE_SUBJECT_WITHOUT_NAME": "You have been invited to join the organisation '%s' on "
    "Flagsmith",
    # The email address invitations will be sent from.
    "INVITE_FROM_EMAIL": DEFAULT_FROM_EMAIL,
}

AWS_SES_REGION_NAME = env("AWS_SES_REGION_NAME", default=None)
AWS_SES_REGION_ENDPOINT = env("AWS_SES_REGION_ENDPOINT", default=None)

# Initialisation settings
# If `ALLOW_ADMIN_INITIATION_VIA_CLI` setting is set to True, Flagsmith will attempt to create
#   1. A superuser
#   2. An organisation
#   3. A project
# with initial values on startup.
# Initialisation is skipped if it's been performed before or if `ALLOW_ADMIN_INITIATION_VIA_CLI` is set to False.
# Tweak (or set via environment) the settings below for custom names, etc.
ALLOW_ADMIN_INITIATION_VIA_URL = env.bool(
    "ALLOW_ADMIN_INITIATION_VIA_URL", default=True
)
ALLOW_ADMIN_INITIATION_VIA_CLI = env.bool(
    "ALLOW_ADMIN_INITIATION_VIA_CLI", default=False
)

ADMIN_EMAIL = env("ADMIN_EMAIL", default="admin@example.com")
ORGANISATION_NAME = env("ORGANISATION_NAME", default="Default Organisation")
PROJECT_NAME = env("PROJECT_NAME", default="Default Project")


AUTH_USER_MODEL = "users.FFAdminUser"

ACCOUNT_USERNAME_REQUIRED = False
ACCOUNT_EMAIL_REQUIRED = True
ACCOUNT_AUTHENTICATION_METHOD = "email"
ACCOUNT_EMAIL_VERIFICATION = "none"  # TODO: configure email verification

# Set up Email
SENDGRID_API_KEY = env("SENDGRID_API_KEY", default=None)

# NOTE: Use `sgbackend.SendGridBackend` as default
# if `SENDGRID_API_KEY` is set in order to maintain backwards compatibility
DEFAULT_EMAIL_BACKEND = (
    "sgbackend.SendGridBackend"
    if SENDGRID_API_KEY
    else "django.core.mail.backends.smtp.EmailBackend"
)

EMAIL_BACKEND = env("EMAIL_BACKEND", default=DEFAULT_EMAIL_BACKEND)

if EMAIL_BACKEND == "django.core.mail.backends.smtp.EmailBackend":
    EMAIL_HOST = env("EMAIL_HOST", default="localhost")
    EMAIL_HOST_USER = env("EMAIL_HOST_USER", default=None)
    EMAIL_HOST_PASSWORD = env("EMAIL_HOST_PASSWORD", default=None)
    EMAIL_PORT = env("EMAIL_PORT", default=587)
    EMAIL_USE_TLS = env.bool("EMAIL_USE_TLS", default=True)

SWAGGER_SETTINGS = {
    "DEEP_LINKING": True,
    "DEFAULT_AUTO_SCHEMA_CLASS": "api.openapi.PydanticResponseCapableSwaggerAutoSchema",
    "SHOW_REQUEST_HEADERS": True,
    "SECURITY_DEFINITIONS": {
        "Private": {
            "type": "apiKey",
            "in": "header",
            "name": "Authorization",
            "description": "For Private Endpoints. <a href='https://docs.flagsmith.com/clients/rest#private-api-endpoints'>Find out more</a>.",  # noqa
        },
        "Public": {
            "type": "apiKey",
            "in": "header",
            "name": "X-Environment-Key",
            "description": "For Public Endpoints. <a href='https://docs.flagsmith.com/clients/rest#public-api-endpoints'>Find out more</a>.",  # noqa
        },
    },
}


LOGIN_URL = "/admin/login/"
LOGOUT_URL = "/admin/logout/"

# Enable E2E tests
E2E_TEST_AUTH_TOKEN = env.str("E2E_TEST_AUTH_TOKEN", default=None)
if E2E_TEST_AUTH_TOKEN is not None:
    MIDDLEWARE.append("e2etests.middleware.E2ETestMiddleware")

ENABLE_FE_E2E = env.bool("ENABLE_FE_E2E", default=False)
# Email associated with user that is used by front end for end to end testing purposes
E2E_TEST_EMAIL_DOMAIN = "flagsmithe2etestdomain.io"
# User email address used for E2E Signup test
E2E_SIGNUP_USER = f"e2e_signup_user@{E2E_TEST_EMAIL_DOMAIN}"
# User email address used for Change email E2E test which is part of invite tests
E2E_CHANGE_EMAIL_USER = f"e2e_change_email@{E2E_TEST_EMAIL_DOMAIN}"
# User email address used for the rest of the E2E tests
E2E_USER = f"e2e_user@{E2E_TEST_EMAIL_DOMAIN}"
E2E_NON_ADMIN_USER_WITH_ORG_PERMISSIONS = (
    f"e2e_non_admin_user_with_org_permissions@{E2E_TEST_EMAIL_DOMAIN}"
)
E2E_NON_ADMIN_USER_WITH_PROJECT_PERMISSIONS = (
    f"e2e_non_admin_user_with_project_permissions@{E2E_TEST_EMAIL_DOMAIN}"
)
E2E_NON_ADMIN_USER_WITH_ENV_PERMISSIONS = (
    f"e2e_non_admin_user_with_env_permissions@{E2E_TEST_EMAIL_DOMAIN}"
)
E2E_NON_ADMIN_USER_WITH_A_ROLE = (
    f"e2e_non_admin_user_with_a_role@{E2E_TEST_EMAIL_DOMAIN}"
)
#  Identity for E2E segment tests
E2E_IDENTITY = "test-identity"

# SSL handling in Django
SECURE_PROXY_SSL_HEADER_NAME = env.str(
    "SECURE_PROXY_SSL_HEADER_NAME", "HTTP_X_FORWARDED_PROTO"
)
SECURE_PROXY_SSL_HEADER_VALUE = env.str("SECURE_PROXY_SSL_HEADER_VALUE", "https")
SECURE_PROXY_SSL_HEADER = (SECURE_PROXY_SSL_HEADER_NAME, SECURE_PROXY_SSL_HEADER_VALUE)

SECURE_REDIRECT_EXEMPT = env.list("DJANGO_SECURE_REDIRECT_EXEMPT", default=[])
SECURE_REFERRER_POLICY = env.str("DJANGO_SECURE_REFERRER_POLICY", default="same-origin")
SECURE_CROSS_ORIGIN_OPENER_POLICY = env.str(
    "DJANGO_SECURE_CROSS_ORIGIN_OPENER_POLICY", default="same-origin"
)
SECURE_SSL_HOST = env.str("DJANGO_SECURE_SSL_HOST", default=None)
SECURE_SSL_REDIRECT = env.bool("DJANGO_SECURE_SSL_REDIRECT", default=False)

# Chargebee
ENABLE_CHARGEBEE = env.bool("ENABLE_CHARGEBEE", default=False)
CHARGEBEE_API_KEY = env("CHARGEBEE_API_KEY", default=None)
CHARGEBEE_SITE = env("CHARGEBEE_SITE", default=None)

# Logging configuration
LOGGING_CONFIGURATION_FILE = env.str("LOGGING_CONFIGURATION_FILE", default=None)
if LOGGING_CONFIGURATION_FILE:
    with open(LOGGING_CONFIGURATION_FILE, "r") as f:
        LOGGING = json.loads(f.read())
else:
    LOG_FORMAT = env.str("LOG_FORMAT", default="generic")
    LOG_LEVEL = env.str("LOG_LEVEL", default="WARNING")
    LOGGING = {
        "version": 1,
        "disable_existing_loggers": False,
        "formatters": {
            "generic": {"format": "%(name)-12s %(levelname)-8s %(message)s"},
            "json": {
                "()": "util.logging.JsonFormatter",
                "datefmt": "%Y-%m-%d %H:%M:%S",
            },
        },
        "handlers": {
            "console": {
                "level": LOG_LEVEL,
                "class": "logging.StreamHandler",
                "formatter": LOG_FORMAT,
            }
        },
        "loggers": {
            "": {"level": LOG_LEVEL, "handlers": ["console"]},
            # Not sure why the following loggers are necessary, but it doesn't seem to
            # write log messages for e.g. features.workflows.core.models without adding
            # them explicitly.
            # TODO: move all apps to a parent 'apps' directory and configure the logger
            #  for that dir
            "features": {
                "level": LOG_LEVEL,
                "handlers": ["console"],
                "propagate": False,
            },
            "task_processor": {
                "level": LOG_LEVEL,
                "handlers": ["console"],
                "propagate": False,
            },
            "app_analytics": {
                "level": LOG_LEVEL,
                "handlers": ["console"],
                "propagate": False,
            },
            "webhooks": {
                "level": LOG_LEVEL,
                "handlers": ["console"],
                "propagate": False,
            },
        },
    }

if APPLICATION_INSIGHTS_CONNECTION_STRING:
    LOGGING["handlers"]["azure"] = {
        "level": "DEBUG",
        "class": "opencensus.ext.azure.log_exporter.AzureLogHandler",
        "connection_string": APPLICATION_INSIGHTS_CONNECTION_STRING,
    }

    LOGGING["loggers"][""]["handlers"].append("azure")

ENABLE_DB_LOGGING = env.bool("DJANGO_ENABLE_DB_LOGGING", default=False)
if ENABLE_DB_LOGGING:  # pragma: no cover
    if not DEBUG:
        warnings.warn("Setting DEBUG=True to ensure DB logging functions correctly.")
        DEBUG = True

    LOGGING["loggers"]["django.db.backends"] = {
        "level": "DEBUG",
        "handlers": ["console"],
    }

CACHE_FLAGS_SECONDS = env.int("CACHE_FLAGS_SECONDS", default=0)
FLAGS_CACHE_LOCATION = "environment-flags"
CHARGEBEE_CACHE_LOCATION = "chargebee-objects"

ENVIRONMENT_CACHE_SECONDS = env.int("ENVIRONMENT_CACHE_SECONDS", default=60)
ENVIRONMENT_CACHE_BACKEND = env.str(
    "ENVIRONMENT_CACHE_BACKEND",
    default="django.core.cache.backends.locmem.LocMemCache",
)
ENVIRONMENT_CACHE_NAME = "environment-objects"
ENVIRONMENT_CACHE_LOCATION = env.str(
    "ENVIRONMENT_CACHE_LOCATION", default=ENVIRONMENT_CACHE_NAME
)

GET_FLAGS_ENDPOINT_CACHE_SECONDS = env.int(
    "GET_FLAGS_ENDPOINT_CACHE_SECONDS", default=0
)
GET_FLAGS_ENDPOINT_CACHE_NAME = "get_flags_endpoint_cache"
GET_FLAGS_ENDPOINT_CACHE_BACKEND = env.str(
    "GET_FLAGS_ENDPOINT_CACHE_BACKEND",
    default="django.core.cache.backends.dummy.DummyCache",
)
GET_FLAGS_ENDPOINT_CACHE_LOCATION = env.str(
    "GET_FLAGS_ENDPOINT_CACHE_LOCATION",
    default=GET_FLAGS_ENDPOINT_CACHE_NAME,
)

GET_IDENTITIES_ENDPOINT_CACHE_SECONDS = env.int(
    "GET_IDENTITIES_ENDPOINT_CACHE_SECONDS", default=0
)
GET_IDENTITIES_ENDPOINT_CACHE_NAME = "get_identities_endpoint_cache"
GET_IDENTITIES_ENDPOINT_CACHE_BACKEND = env.str(
    "GET_IDENTITIES_ENDPOINT_CACHE_BACKEND",
    default="django.core.cache.backends.dummy.DummyCache",
)
GET_IDENTITIES_ENDPOINT_CACHE_LOCATION = env.str(
    "GET_IDENTITIES_ENDPOINT_CACHE_LOCATION",
    default=GET_IDENTITIES_ENDPOINT_CACHE_NAME,
)

BAD_ENVIRONMENTS_CACHE_LOCATION = "bad-environments"
CACHE_BAD_ENVIRONMENTS_SECONDS = env.int("CACHE_BAD_ENVIRONMENTS_SECONDS", 0)
CACHE_BAD_ENVIRONMENTS_AFTER_FAILURES = env.int(
    "CACHE_BAD_ENVIRONMENTS_AFTER_FAILURES", 1
)

CACHE_PROJECT_SEGMENTS_SECONDS = env.int("CACHE_PROJECT_SEGMENTS_SECONDS", 0)
PROJECT_SEGMENTS_CACHE_LOCATION = "project-segments"

ENVIRONMENT_SEGMENTS_CACHE_NAME = "environment-segments"
ENVIRONMENT_SEGMENTS_CACHE_SECONDS = env.int("CACHE_ENVIRONMENT_SEGMENTS_SECONDS", 0)
ENVIRONMENT_SEGMENTS_CACHE_LOCATION = env(
    "ENVIRONMENT_SEGMENTS_CACHE_LOCATION", "environment-segments"
)
ENVIRONMENT_SEGMENTS_CACHE_BACKEND = env(
    "CACHE_ENVIRONMENT_SEGMENTS_BACKEND",
    "django.core.cache.backends.locmem.LocMemCache",
)

CACHE_ENVIRONMENT_DOCUMENT_SECONDS = env.int("CACHE_ENVIRONMENT_DOCUMENT_SECONDS", 0)
ENVIRONMENT_DOCUMENT_CACHE_LOCATION = "environment-documents"

USER_THROTTLE_CACHE_NAME = "user-throttle"
USER_THROTTLE_CACHE_BACKEND = env.str(
    "USER_THROTTLE_CACHE_BACKEND", "django.core.cache.backends.locmem.LocMemCache"
)
USER_THROTTLE_CACHE_LOCATION = env.str("USER_THROTTLE_CACHE_LOCATION", "admin-throttle")
USER_THROTTLE_CACHE_OPTIONS = env.dict("USER_THROTTLE_CACHE_OPTIONS", default={})

# Using Redis for cache
# To use Redis for caching, set the cache backend to `django_redis.cache.RedisCache`.
# and set the cache location to the redis url
# ref: https://github.com/jazzband/django-redis/tree/5.4.0#configure-as-cache-backend


# Avoid raising exceptions if redis is down
# ref: https://github.com/jazzband/django-redis/tree/5.4.0#memcached-exceptions-behavior
DJANGO_REDIS_IGNORE_EXCEPTIONS = env.bool(
    "DJANGO_REDIS_IGNORE_EXCEPTIONS", default=True
)

# Log exceptions generated by django-redis
# ref:https://github.com/jazzband/django-redis/tree/5.4.0#log-ignored-exceptions
DJANGO_REDIS_LOG_IGNORED_EXCEPTIONS = env.bool(
    "DJANGO_REDIS_LOG_IGNORED_EXCEPTIONS", True
)

CACHES = {
    "default": {
        "BACKEND": "django.core.cache.backends.locmem.LocMemCache",
        "LOCATION": "unique-snowflake",
    },
    ENVIRONMENT_CACHE_NAME: {
        "BACKEND": ENVIRONMENT_CACHE_BACKEND,
        "LOCATION": ENVIRONMENT_CACHE_LOCATION,
        "TIMEOUT": ENVIRONMENT_CACHE_SECONDS,
    },
    FLAGS_CACHE_LOCATION: {
        "BACKEND": "django.core.cache.backends.locmem.LocMemCache",
        "LOCATION": FLAGS_CACHE_LOCATION,
    },
    PROJECT_SEGMENTS_CACHE_LOCATION: {
        "BACKEND": "django.core.cache.backends.locmem.LocMemCache",
        "LOCATION": PROJECT_SEGMENTS_CACHE_LOCATION,
    },
    BAD_ENVIRONMENTS_CACHE_LOCATION: {
        "BACKEND": "django.core.cache.backends.locmem.LocMemCache",
        "LOCATION": BAD_ENVIRONMENTS_CACHE_LOCATION,
        "OPTIONS": {"MAX_ENTRIES": 50},
    },
    CHARGEBEE_CACHE_LOCATION: {
        "BACKEND": "django.core.cache.backends.db.DatabaseCache",
        "LOCATION": CHARGEBEE_CACHE_LOCATION,
        "TIMEOUT": 12 * 60 * 60,  # 12 hours
    },
    ENVIRONMENT_DOCUMENT_CACHE_LOCATION: {
        "BACKEND": "django.core.cache.backends.db.DatabaseCache",
        "LOCATION": ENVIRONMENT_DOCUMENT_CACHE_LOCATION,
        "timeout": CACHE_ENVIRONMENT_DOCUMENT_SECONDS,
    },
    GET_FLAGS_ENDPOINT_CACHE_NAME: {
        "BACKEND": GET_FLAGS_ENDPOINT_CACHE_BACKEND,
        "LOCATION": GET_FLAGS_ENDPOINT_CACHE_LOCATION,
    },
    GET_IDENTITIES_ENDPOINT_CACHE_NAME: {
        "BACKEND": GET_IDENTITIES_ENDPOINT_CACHE_BACKEND,
        "LOCATION": GET_IDENTITIES_ENDPOINT_CACHE_LOCATION,
    },
    ENVIRONMENT_SEGMENTS_CACHE_NAME: {
        "BACKEND": ENVIRONMENT_SEGMENTS_CACHE_BACKEND,
        "LOCATION": ENVIRONMENT_SEGMENTS_CACHE_LOCATION,
        "TIMEOUT": ENVIRONMENT_SEGMENTS_CACHE_SECONDS,
    },
    USER_THROTTLE_CACHE_NAME: {
        "BACKEND": USER_THROTTLE_CACHE_BACKEND,
        "LOCATION": USER_THROTTLE_CACHE_LOCATION,
        "OPTIONS": USER_THROTTLE_CACHE_OPTIONS,
    },
}

TRENCH_AUTH = {
    "BACKUP_CODES_QUANTITY": 5,
    "BACKUP_CODES_LENGTH": 10,  # keep (quantity * length) under 200
    "BACKUP_CODES_CHARACTERS": (
        "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
    ),
    "DEFAULT_VALIDITY_PERIOD": 30,
    "CONFIRM_BACKUP_CODES_REGENERATION_WITH_CODE": True,
    "APPLICATION_ISSUER_NAME": "Flagsmith",
    "ENCRYPT_BACKUP_CODES": True,
    "MFA_METHODS": {
        "app": {
            "VERBOSE_NAME": "TOTP App",
            "VALIDITY_PERIOD": 60 * 10,
            "USES_THIRD_PARTY_CLIENT": True,
            "HANDLER": "custom_auth.mfa.backends.application.CustomApplicationBackend",
        },
    },
    "SECRET_KEY_LENGTH": 32,
}

USER_CREATE_PERMISSIONS = env.list(
    "USER_CREATE_PERMISSIONS", default=["custom_auth.permissions.IsSignupAllowed"]
)
USER_LOGIN_PERMISSIONS = env.list(
    "USER_LOGIN_PERMISSIONS", default=["custom_auth.permissions.IsPasswordLoginAllowed"]
)

DJOSER = {
    "PASSWORD_RESET_CONFIRM_URL": "password-reset/confirm/{uid}/{token}",
    # if True user required to click activation link in email to activate account
    "SEND_ACTIVATION_EMAIL": env.bool("ENABLE_EMAIL_ACTIVATION", default=False),
    # FE uri to redirect user to from activation email
    "ACTIVATION_URL": "activate/{uid}/{token}",
    # register or activation endpoint will send confirmation email to user
    "LOGIN_FIELD": "email",
    "SEND_CONFIRMATION_EMAIL": False,
    "SERIALIZERS": {
        "token": "custom_auth.serializers.CustomTokenSerializer",
        "user_create": "custom_auth.serializers.CustomUserCreateSerializer",
        "user_delete": "custom_auth.serializers.CustomUserDelete",
        "current_user": "users.serializers.CustomCurrentUserSerializer",
    },
    "EMAIL": {
        "activation": "users.emails.ActivationEmail",
        "confirmation": "users.emails.ConfirmationEmail",
    },
    "SET_PASSWORD_RETYPE": True,
    "PASSWORD_RESET_CONFIRM_RETYPE": True,
    "HIDE_USERS": True,
    "PERMISSIONS": {
        "user": ["custom_auth.permissions.CurrentUser"],
        "user_list": ["custom_auth.permissions.CurrentUser"],
        "user_create": USER_CREATE_PERMISSIONS,
        "token_create": USER_LOGIN_PERMISSIONS,
    },
}
SIMPLE_JWT = {
    "AUTH_TOKEN_CLASSES": ["rest_framework_simplejwt.tokens.SlidingToken"],
    "SLIDING_TOKEN_LIFETIME": timedelta(
        minutes=env.int(
            "COOKIE_AUTH_JWT_ACCESS_TOKEN_LIFETIME_MINUTES",
            default=10 * 60,
        )
    ),
    "SIGNING_KEY": env.str("COOKIE_AUTH_JWT_SIGNING_KEY", default=SECRET_KEY),
}

# Github OAuth credentials
GITHUB_CLIENT_ID = env.str("GITHUB_CLIENT_ID", default="")
GITHUB_CLIENT_SECRET = env.str("GITHUB_CLIENT_SECRET", default="")

# Allow the configuration of registration via OAuth
ALLOW_REGISTRATION_WITHOUT_INVITE = env.bool(
    "ALLOW_REGISTRATION_WITHOUT_INVITE", default=True
)

# Django Axes settings
ENABLE_AXES = env.bool("ENABLE_AXES", default=True)
if ENABLE_AXES:
    # must be the first item in the auth backends
    AUTHENTICATION_BACKENDS.insert(0, "axes.backends.AxesBackend")

    # must be the last item in the middleware stack
    MIDDLEWARE.append("core.middleware.axes.AxesMiddleware")

    AXES_COOLOFF_TIME = timedelta(minutes=env.int("AXES_COOLOFF_TIME", 15))
    AXES_BLACKLISTED_URLS = [
        "/admin/login/?next=/admin",
        "/admin/",
    ]
    AXES_ONLY_USER_FAILURES = env.bool("AXES_ONLY_USER_FAILURES", True)
    AXES_FAILURE_LIMIT = env.int("AXES_FAILURE_LIMIT", 10)


# Sentry tracking
SENTRY_SDK_DSN = env("SENTRY_SDK_DSN", default=None)
DEFAULT_SENTRY_TRACE_SAMPLE_RATE = env.float("SENTRY_TRACE_SAMPLE_RATE", default=1.0)
DASHBOARD_ENDPOINTS_SENTRY_TRACE_SAMPLE_RATE = env.float(
    "DASHBOARD_ENDPOINTS_SENTRY_TRACE_SAMPLE_RATE", default=1.0
)
FORCE_SENTRY_TRACE_KEY = env("FORCE_SENTRY_TRACE_KEY", default=None)
if FORCE_SENTRY_TRACE_KEY:
    MIDDLEWARE.append("integrations.sentry.middleware.ForceSentryTraceMiddleware")

# allow users to access the admin console
ENABLE_ADMIN_ACCESS_USER_PASS = env.bool("ENABLE_ADMIN_ACCESS_USER_PASS", default=None)

# Set this flag to prevent traits being stored for all Organisations within the application
# Useful for data sensitive installations that dont want persistent traits.
DEFAULT_ORG_STORE_TRAITS_VALUE = env.bool("DEFAULT_ORG_STORE_TRAITS_VALUE", True)

# DynamoDB table name for storing environment
ENVIRONMENTS_TABLE_NAME_DYNAMO = env.str("ENVIRONMENTS_TABLE_NAME_DYNAMO", None)

# V2 was created to improve storage over overrides data.
ENVIRONMENTS_V2_TABLE_NAME_DYNAMO = env.str("ENVIRONMENTS_V2_TABLE_NAME_DYNAMO", None)

# DynamoDB table name for storing identities
IDENTITIES_TABLE_NAME_DYNAMO = env.str("IDENTITIES_TABLE_NAME_DYNAMO", None)

# DynamoDB table name for storing environment api keys
ENVIRONMENTS_API_KEY_TABLE_NAME_DYNAMO = env.str(
    "ENVIRONMENTS_API_KEY_TABLE_NAME_DYNAMO", None
)

# DynamoDB table name for storing project metadata(currently only used for identity migration)
PROJECT_METADATA_TABLE_NAME_DYNAMO = env.str("PROJECT_METADATA_TABLE_NAME_DYNAMO", None)

# Front end environment variables
API_URL = env("API_URL", default="/api/v1/")
ASSET_URL = env("ASSET_URL", default="/")
MAINTENANCE_MODE = env.bool("MAINTENANCE_MODE", default=False)
DISABLE_ANALYTICS_FEATURES = env.bool(
    "DISABLE_INFLUXDB_FEATURES", default=False
) or env.bool("DISABLE_ANALYTICS_FEATURES", default=False)
FLAGSMITH_ANALYTICS = env.bool("FLAGSMITH_ANALYTICS", default=False)
FLAGSMITH_ON_FLAGSMITH_API_URL = env("FLAGSMITH_ON_FLAGSMITH_API_URL", default=None)
FLAGSMITH_ON_FLAGSMITH_API_KEY = env("FLAGSMITH_ON_FLAGSMITH_API_KEY", default=None)
LINKEDIN_PARTNER_TRACKING = env("LINKEDIN_PARTNER_TRACKING", default=False)
GOOGLE_ANALYTICS_API_KEY = env("GOOGLE_ANALYTICS_API_KEY", default=None)
HEADWAY_API_KEY = env("HEADWAY_API_KEY", default=None)
CRISP_CHAT_API_KEY = env("CRISP_CHAT_API_KEY", default=None)
MIXPANEL_API_KEY = env("MIXPANEL_API_KEY", default=None)
SENTRY_API_KEY = env("SENTRY_API_KEY", default=None)
AMPLITUDE_API_KEY = env("AMPLITUDE_API_KEY", default=None)
ENABLE_FLAGSMITH_REALTIME = env.bool("ENABLE_FLAGSMITH_REALTIME", default=False)

# Set this to enable create organisation for only superusers
RESTRICT_ORG_CREATE_TO_SUPERUSERS = env.bool("RESTRICT_ORG_CREATE_TO_SUPERUSERS", False)
# Slack Integration
SLACK_CLIENT_ID = env.str("SLACK_CLIENT_ID", default="")
SLACK_CLIENT_SECRET = env.str("SLACK_CLIENT_SECRET", default="")
# GitHub integrations
GITHUB_PEM = env.str("GITHUB_PEM", default="")
GITHUB_APP_ID: int = env.int("GITHUB_APP_ID", default=0)
GITHUB_WEBHOOK_SECRET = env.str("GITHUB_WEBHOOK_SECRET", default="")

# Additional functionality for using SAML in Flagsmith SaaS
SAML_INSTALLED = importlib.util.find_spec("saml") is not None

if SAML_INSTALLED:
    SAML_REQUESTS_CACHE_LOCATION = "saml_requests_cache"
    CACHES[SAML_REQUESTS_CACHE_LOCATION] = {
        "BACKEND": "django.core.cache.backends.db.DatabaseCache",
        "LOCATION": SAML_REQUESTS_CACHE_LOCATION,
    }
    INSTALLED_APPS.append("saml")
    SAML_ACCEPTED_TIME_DIFF = env.int("SAML_ACCEPTED_TIME_DIFF", default=60)
    DJOSER["SERIALIZERS"]["current_user"] = "saml.serializers.SamlCurrentUserSerializer"
    EXTRA_ALLOWED_CANONICALIZATIONS = env.list(
        "EXTRA_ALLOWED_CANONICALIZATIONS", default=[]
    )


WORKFLOWS_LOGIC_INSTALLED = importlib.util.find_spec("workflows_logic") is not None

if WORKFLOWS_LOGIC_INSTALLED:
    INSTALLED_APPS.append("workflows_logic")

    if importlib.util.find_spec("workflows_logic.stale_flags") is not None:
        INSTALLED_APPS.append("workflows_logic.stale_flags")

# Additional functionality for restricting authentication to a set of authentication methods in Flagsmith SaaS
AUTH_CONTROLLER_INSTALLED = importlib.util.find_spec("auth_controller") is not None
if AUTH_CONTROLLER_INSTALLED:
    INSTALLED_APPS.append("auth_controller")
    AUTHENTICATION_BACKENDS.insert(0, "auth_controller.backends.AuthControllerBackend")

IS_RBAC_INSTALLED = importlib.util.find_spec("rbac") is not None
if IS_RBAC_INSTALLED:
    INSTALLED_APPS.append("rbac")

DEFAULT_AUTO_FIELD = "django.db.models.AutoField"

# Used to keep edge identities in sync by forwarding the http requests
EDGE_API_URL = env.str("EDGE_API_URL", None)
# Used for signing forwarded request to edge
EDGE_REQUEST_SIGNING_KEY = env.str("EDGE_REQUEST_SIGNING_KEY", None)

# Aws Event bus used for sending identity migration events
IDENTITY_MIGRATION_EVENT_BUS_NAME = env.str("IDENTITY_MIGRATION_EVENT_BUS_NAME", None)

# Should be a string representing a timezone aware datetime, e.g. 2022-03-31T12:35:00Z
EDGE_RELEASE_DATETIME = env.datetime("EDGE_RELEASE_DATETIME", None)
# Note: using django.utils.timezone.now doesn't work reliably in settings so we use
# datetime.now
EDGE_ENABLED = (
    ENVIRONMENTS_TABLE_NAME_DYNAMO is not None
    and EDGE_RELEASE_DATETIME is not None
    and EDGE_RELEASE_DATETIME < datetime.now(tz=pytz.UTC)
)

DISABLE_FLAGSMITH_UI = env.bool("DISABLE_FLAGSMITH_UI", default=False)
SERVE_FE_ASSETS = not DISABLE_FLAGSMITH_UI and os.path.exists(
    BASE_DIR + "/app/templates/webpack/index.html"
)

# Used to configure the number of application proxies that the API runs behind
NUM_PROXIES = env.int("NUM_PROXIES", 1)

SAML_USE_NAME_ID_AS_EMAIL = env.bool("SAML_USE_NAME_ID_AS_EMAIL", False)

# Used to control the size(number of identities) of the project that can be self migrated to edge
MAX_SELF_MIGRATABLE_IDENTITIES = env.int("MAX_SELF_MIGRATABLE_IDENTITIES", 100000)

# Setting to allow asynchronous tasks to be run synchronously for testing purposes
# or in a separate thread for self-hosted users
TASK_RUN_METHOD = env.enum(
    "TASK_RUN_METHOD",
    type=TaskRunMethod,
    default=(
        TaskRunMethod.TASK_PROCESSOR.value
        if env.bool("RUN_BY_PROCESSOR", False)
        else TaskRunMethod.SEPARATE_THREAD.value
    ),
)
ENABLE_TASK_PROCESSOR_HEALTH_CHECK = env.bool(
    "ENABLE_TASK_PROCESSOR_HEALTH_CHECK", default=False
)

# Allows us to prevent the postpone decorator from running things async
ENABLE_POSTPONE_DECORATOR = env.bool("ENABLE_POSTPONE_DECORATOR", default=True)

ENABLE_CLEAN_UP_OLD_TASKS = env.bool("ENABLE_CLEAN_UP_OLD_TASKS", default=True)
TASK_DELETE_RETENTION_DAYS = env.int("TASK_DELETE_RETENTION_DAYS", default=30)
TASK_DELETE_BATCH_SIZE = env.int("TASK_DELETE_BATCH_SIZE", default=2000)
TASK_DELETE_INCLUDE_FAILED_TASKS = env.bool(
    "TASK_DELETE_INCLUDE_FAILED_TASKS", default=False
)
TASK_DELETE_RUN_TIME = env.time("TASK_DELETE_RUN_TIME", default="01:00")
TASK_DELETE_RUN_EVERY = env.timedelta("TASK_DELETE_RUN_EVERY", default=86400)
RECURRING_TASK_RUN_RETENTION_DAYS = env.int(
    "RECURRING_TASK_RUN_RETENTION_DAYS", default=30
)

# Webhook settings
DISABLE_WEBHOOKS = env.bool("DISABLE_WEBHOOKS", False)
RETRY_WEBHOOKS = TASK_RUN_METHOD == TaskRunMethod.TASK_PROCESSOR

# Real time(server sent events) settings
SSE_SERVER_BASE_URL = env.str("SSE_SERVER_BASE_URL", None)
SSE_AUTHENTICATION_TOKEN = env.str("SSE_AUTHENTICATION_TOKEN", None)
AWS_SSE_LOGS_BUCKET_NAME = env.str("AWS_SSE_LOGS_BUCKET_NAME", None)

RAW_ANALYTICS_DATA_RETENTION_DAYS = env.int("RAW_ANALYTICS_DATA_RETENTION_DAYS", 30)
BUCKETED_ANALYTICS_DATA_RETENTION_DAYS = env.int(
    "BUCKETED_ANALYTICS_DATA_RETENTION_DAYS", 90
)

DISABLE_INVITE_LINKS = env.bool("DISABLE_INVITE_LINKS", False)
PREVENT_SIGNUP = env.bool("PREVENT_SIGNUP", default=False)
PREVENT_EMAIL_PASSWORD = env.bool("PREVENT_EMAIL_PASSWORD", default=False)
COOKIE_AUTH_ENABLED = env.bool("COOKIE_AUTH_ENABLED", default=False)
USE_SECURE_COOKIES = env.bool("USE_SECURE_COOKIES", default=True)
COOKIE_SAME_SITE = env.str("COOKIE_SAME_SITE", default="none")

# CORS settings

CORS_ORIGIN_ALLOW_ALL = env.bool("CORS_ORIGIN_ALLOW_ALL", not COOKIE_AUTH_ENABLED)
CORS_ALLOW_CREDENTIALS = env.bool("CORS_ALLOW_CREDENTIALS", COOKIE_AUTH_ENABLED)
FLAGSMITH_CORS_EXTRA_ALLOW_HEADERS = env.list(
    "FLAGSMITH_CORS_EXTRA_ALLOW_HEADERS", default=["sentry-trace"]
)
CORS_ALLOWED_ORIGINS = env.list("CORS_ALLOWED_ORIGINS", default=[])
CORS_ALLOW_HEADERS = [
    *default_headers,
    *FLAGSMITH_CORS_EXTRA_ALLOW_HEADERS,
    "X-Environment-Key",
    "X-E2E-Test-Auth-Token",
]

# use a separate boolean setting so that we add it to the API containers in environments
# where we're running the task processor, so we avoid creating unnecessary tasks
ENABLE_PIPEDRIVE_LEAD_TRACKING = env.bool("ENABLE_PIPEDRIVE_LEAD_TRACKING", False)
PIPEDRIVE_API_TOKEN = env.str("PIPEDRIVE_API_TOKEN", None)
PIPEDRIVE_BASE_API_URL = env.str(
    "PIPEDRIVE_BASE_API_URL", "https://flagsmith.pipedrive.com/api/v1"
)
PIPEDRIVE_DOMAIN_ORGANIZATION_FIELD_KEY = env.str(
    "PIPEDRIVE_DOMAIN_ORGANIZATION_FIELD_KEY", None
)
PIPEDRIVE_SIGN_UP_TYPE_DEAL_FIELD_KEY = env.str(
    "PIPEDRIVE_SIGN_UP_TYPE_DEAL_FIELD_KEY", None
)
PIPEDRIVE_API_LEAD_SOURCE_DEAL_FIELD_KEY = env.str(
    "PIPEDRIVE_API_LEAD_SOURCE_DEAL_FIELD_KEY", None
)
PIPEDRIVE_API_LEAD_SOURCE_VALUE = env.str(
    "PIPEDRIVE_API_LEAD_SOURCE_VALUE", "App Sign-up"
)
PIPEDRIVE_IGNORE_DOMAINS = env.list("PIPEDRIVE_IGNORE_DOMAINS", [])
PIPEDRIVE_IGNORE_DOMAINS_REGEX = env("PIPEDRIVE_IGNORE_DOMAINS_REGEX", "")
PIPEDRIVE_LEAD_LABEL_EXISTING_CUSTOMER_ID = env(
    "PIPEDRIVE_LEAD_LABEL_EXISTING_CUSTOMER_ID", None
)

# Hubspot settings
HUBSPOT_ACCESS_TOKEN = env.str("HUBSPOT_ACCESS_TOKEN", None)
ENABLE_HUBSPOT_LEAD_TRACKING = env.bool("ENABLE_HUBSPOT_LEAD_TRACKING", False)
HUBSPOT_IGNORE_DOMAINS = env.list("HUBSPOT_IGNORE_DOMAINS", [])
HUBSPOT_IGNORE_DOMAINS_REGEX = env("HUBSPOT_IGNORE_DOMAINS_REGEX", "")
HUBSPOT_IGNORE_ORGANISATION_DOMAINS = env.list(
    "HUBSPOT_IGNORE_ORGANISATION_DOMAINS", []
)

# Number of minutes to wait for a user that has signed up to
# join or create an organisation before creating a lead in
# hubspot without a Flagsmith organisation.
CREATE_HUBSPOT_LEAD_WITHOUT_ORGANISATION_DELAY_MINUTES = 30

# List of plan ids that support seat upgrades
AUTO_SEAT_UPGRADE_PLANS = env.list("AUTO_SEAT_UPGRADE_PLANS", default=[])


SKIP_MIGRATION_TESTS = env.bool("SKIP_MIGRATION_TESTS", False)

# prevent django-softdelete from performing whole table deletes!
SOFTDELETE_CASCADE_ALLOW_DELETE_ALL = False

# Used for serializing and deserializing GenericForeignKey(used in metadata) using the natural key of the object
SERIALIZATION_MODULES = {"json": "import_export.json_serializers_with_metadata_support"}

# Controls the app domain used in emails (currently invites and change requests).
# If set, domain stored with `django.contrib.sites` is disregarded.
DOMAIN_OVERRIDE = env.str("FLAGSMITH_DOMAIN", "")
# Used when no Django site is specified.
DEFAULT_DOMAIN = "app.flagsmith.com"

# Define the cooldown duration, in seconds, for password reset emails
PASSWORD_RESET_EMAIL_COOLDOWN = env.int("PASSWORD_RESET_EMAIL_COOLDOWN", 60 * 60 * 24)

# Limit the count of password reset emails that can be dispatched within the `PASSWORD_RESET_EMAIL_COOLDOWN` timeframe.
MAX_PASSWORD_RESET_EMAILS = env.int("MAX_PASSWORD_RESET_EMAILS", 5)

FLAGSMITH_ON_FLAGSMITH_SERVER_OFFLINE_MODE = env.bool(
    "FLAGSMITH_ON_FLAGSMITH_SERVER_OFFLINE_MODE", default=True
)
FLAGSMITH_ON_FLAGSMITH_SERVER_KEY = env(
    "FLAGSMITH_ON_FLAGSMITH_SERVER_KEY", default=None
)
FLAGSMITH_ON_FLAGSMITH_SERVER_API_URL = env(
    "FLAGSMITH_ON_FLAGSMITH_SERVER_API_URL", default=FLAGSMITH_ON_FLAGSMITH_API_URL
)

FLAGSMITH_ON_FLAGSMITH_FEATURE_EXPORT_ENVIRONMENT_ID = env.int(
    "FLAGSMITH_ON_FLAGSMITH_FEATURE_EXPORT_ENVIRONMENT_ID",
    default=None,
)
FLAGSMITH_ON_FLAGSMITH_FEATURE_EXPORT_TAG_ID = env.int(
    "FLAGSMITH_ON_FLAGSMITH_FEATURE_EXPORT_TAG_ID",
    default=None,
)

# The URL used to install the GitHub integration
GITHUB_APP_URL = env.int(
    "GITHUB_APP_URL",
    default=None,
)

# LDAP setting
LDAP_INSTALLED = importlib.util.find_spec("flagsmith_ldap")
# The URL of the LDAP server.
LDAP_AUTH_URL = env.str("LDAP_AUTH_URL", None)
LDAP_ENABLED = LDAP_INSTALLED and LDAP_AUTH_URL

if LDAP_ENABLED:  # pragma: no cover
    AUTHENTICATION_BACKENDS.insert(0, "django_python3_ldap.auth.LDAPBackend")
    INSTALLED_APPS.append("flagsmith_ldap")

    # Initiate TLS on connection.
    LDAP_AUTH_USE_TLS = env.bool("LDAP_AUTH_USE_TLS", False)

    # The LDAP search base for looking up users.
    LDAP_AUTH_SEARCH_BASE = env.str(
        "LDAP_AUTH_SEARCH_BASE", "ou=people,dc=example,dc=com"
    )

    # The LDAP class that represents a user.
    LDAP_AUTH_OBJECT_CLASS = env.str("LDAP_AUTH_OBJECT_CLASS", "inetOrgPerson")

    # User model fields mapped to the LDAP
    # attributes that represent them.
    LDAP_AUTH_USER_FIELDS = env.dict(
        "LDAP_AUTH_USER_FIELDS",
        {
            "username": "uid",
            "first_name": "givenName",
            "last_name": "sn",
            "email": "mail",
        },
    )
    # Sets the login domain for Active Directory users.
    LDAP_AUTH_ACTIVE_DIRECTORY_DOMAIN = env.str(
        "LDAP_AUTH_ACTIVE_DIRECTORY_DOMAIN", None
    )

    # Path to a callable that takes a dict of {model_field_name: value}, and returns
    # a string of the username to bind to the LDAP server.
    # Use this to support different types of LDAP server.
    LDAP_AUTH_FORMAT_USERNAME = env.str(
        "LDAP_AUTH_FORMAT_USERNAME",
        "django_python3_ldap.utils.format_username_openldap",
    )

    # Set connection/receive timeouts (in seconds) on the underlying `ldap3` library.
    LDAP_AUTH_CONNECT_TIMEOUT = env.int("LDAP_AUTH_CONNECT_TIMEOUT", None)
    LDAP_AUTH_RECEIVE_TIMEOUT = env.int("LDAP_AUTH_RECEIVE_TIMEOUT", None)

    # Set this to add newly created users to an organisation
    LDAP_DEFAULT_FLAGSMITH_ORGANISATION_ID = env.int(
        "LDAP_DEFAULT_FLAGSMITH_ORGANISATION_ID", None
    )

    # Path to a callable that takes a user model, a dict of {ldap_field_name: [value]}
    # a LDAP connection object (to allow further lookups), and saves any additional
    # user relationships based on the LDAP data.
    LDAP_AUTH_SYNC_USER_RELATIONS = env.str(
        "LDAP_AUTH_SYNC_USER_RELATIONS", "django_python3_ldap.utils.sync_user_relations"
    )

    # Path to a callable that takes a dict of {ldap_field_name: value},
    # returning a list of [ldap_search_filter]. The search filters will then be AND'd
    # together when creating the final search filter.
    LDAP_AUTH_FORMAT_SEARCH_FILTERS = env.str(
        "LDAP_AUTH_FORMAT_SEARCH_FILTERS",
        default="django_python3_ldap.utils.format_search_filters",
    )

    # List of LDAP group DN's that needs to be synced.
    LDAP_SYNCED_GROUPS = env.list("LDAP_SYNCED_GROUPS", default=[], delimiter=":")

    # DN of the LDAP group that is allowed to login
    # If None no group check will be performed.
    LDAP_LOGIN_GROUP = env.str("LDAP_LOGIN_GROUP", None)

    # The LDAP user username and password used by `sync_ldap_users_and_groups` command
    LDAP_SYNC_USER_USERNAME = env.str("LDAP_SYNC_USER_USERNAME", None)
    LDAP_SYNC_USER_PASSWORD = env.str("LDAP_SYNC_USER_PASSWORD", None)

SEGMENT_CONDITION_VALUE_LIMIT = env.int("SEGMENT_CONDITION_VALUE_LIMIT", default=1000)
if not 0 <= SEGMENT_CONDITION_VALUE_LIMIT < 2000000:
    raise ImproperlyConfigured(
        "SEGMENT_CONDITION_VALUE_LIMIT must be between 0 and 2,000,000 (2MB)."
    )

FEATURE_VALUE_LIMIT = env.int("FEATURE_VALUE_LIMIT", default=20_000)
if not 0 <= FEATURE_VALUE_LIMIT <= 2000000:  # pragma: no cover
    raise ImproperlyConfigured(
        "FEATURE_VALUE_LIMIT must be between 0 and 2,000,000 (2MB)."
    )

SEGMENT_RULES_CONDITIONS_LIMIT = env.int("SEGMENT_RULES_CONDITIONS_LIMIT", 100)

WEBHOOK_BACKOFF_BASE = env.int("WEBHOOK_BACKOFF_BASE", default=2)
WEBHOOK_BACKOFF_RETRIES = env.int("WEBHOOK_BACKOFF_RETRIES", default=3)

# Split Testing settings
SPLIT_TESTING_INSTALLED = importlib.util.find_spec("split_testing")
if SPLIT_TESTING_INSTALLED:
    INSTALLED_APPS += ("split_testing",)

ENABLE_API_USAGE_ALERTING = env.bool("ENABLE_API_USAGE_ALERTING", default=False)

# See DomainAuthMethods in flagsmith-auth-controller repository with auth_controller.models module
GLOBAL_DOMAIN_AUTH_METHODS = env.dict(
    "GLOBAL_DOMAIN_AUTH_METHODS",
    {
        "EP": True,  # Email / Password
        "GO": True,  # Google
        "GH": True,  # GitHub
        "SAML": True,  # Security Assertion Markup Language
    },
)

EDGE_V2_MIGRATION_READ_CAPACITY_BUDGET = env.int(
    "EDGE_V2_MIGRATION_READ_CAPACITY_BUDGET",
    default=0,
)

ORG_SUBSCRIPTION_CANCELLED_ALERT_RECIPIENT_LIST = env.list(
    "ORG_SUBSCRIPTION_CANCELLED_ALERT_RECIPIENT_LIST", default=[]
)

# Date on which versioning is released. This is used to give any scale up
# subscriptions created before this date full audit log and versioning
# history.
VERSIONING_RELEASE_DATE = env.date("VERSIONING_RELEASE_DATE", default=None)

SUBSCRIPTION_LICENCE_PUBLIC_KEY = env.str(
    "SUBSCRIPTION_LICENCE_PUBLIC_KEY",
    """
-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAs1H23Xv1IlhyTbUP9Z4e
zN3t6oa97ybLufhqSRCoPxHWAY/pqqjdwiC00AnRbL/guDi1FLPEkLza2gAKfU+f
04SsNTfYL5MTPnaFtf+B+hlYmlrT1C6n05t+uQW2OQm6mWoqBssmoyR8T5FXfBls
FrT8dsZg5XG7JaWAyGbbVscHrXHXqVcLbFGO8CcO2BG2whl+7hzm4edNCsxLJqmN
uASR9KtntdulkRar0A9x+hAQUlrDKv77nMMdljNIqkcCcWrbhiDoTVCDbE99mhMq
LeC/+C54/ZiCb3r9woq/kpsbRj0Ys2b4czfjWioXooSxA0w3BE6/lV0+hVltjRO6
5QIDAQAB
-----END PUBLIC KEY-----
""",
)

# For the matching private key to the public key added above
# search for "Flagsmith licence private key" in Bitwarden.
SUBSCRIPTION_LICENCE_PRIVATE_KEY = env.str("SUBSCRIPTION_LICENCE_PRIVATE_KEY", None)

LICENSING_INSTALLED = importlib.util.find_spec("licensing") is not None

if LICENSING_INSTALLED:  # pragma: no cover
    INSTALLED_APPS.append("licensing")
