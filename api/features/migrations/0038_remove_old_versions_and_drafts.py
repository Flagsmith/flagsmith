# Generated by Django 3.2.12 on 2022-02-28 15:29

from django.db import migrations


from features.constants import DRAFT


sub_query = """
    select
        distinct fs1.id
    from
        features_featurestate fs1
    left outer join features_featurestate fs2 on
        (fs1.environment_id = fs2.environment_id
            and fs1.feature_id = fs2.feature_id
            and (fs1.identity_id = fs2.identity_id
                or (fs1.identity_id is null
                    and fs2.identity_id is null))
            and (fs1.feature_segment_id = fs2.feature_segment_id
                or (fs1.feature_segment_id is null
                    and fs2.feature_segment_id is null))
            and fs1.version < fs2.version
            and fs2.live_from < now())
    where
        (fs2.id is not null
            or fs1.live_from > now())
"""


# second query uses a named temporary table to get around mysql restriction as can be
# seen here:
# https://stackoverflow.com/questions/45494/mysql-error-1093-cant-specify-target-table-for-update-in-from-clause
sql = f"""
    delete from features_featurestatevalue 
    where feature_state_id in ({sub_query});

    delete from features_featurestate
    where id in (select id from ({sub_query}) as temp);
"""


class Migration(migrations.Migration):
    """
    This migration removes all old / unreleased feature states from the database so
    that the old unique constraints can be added again.

    We do this using raw SQL since the django approach caused problems when migrating
    backwards and unapplying more than one migration.
    """

    dependencies = [
        ("features", "0037_add_feature_state_versioning_fields"),
    ]

    operations = [
        migrations.RunSQL(sql="", reverse_sql=sql),
    ]
