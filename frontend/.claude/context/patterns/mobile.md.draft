# Mobile-Specific Patterns

## Toast Notifications

Mobile uses `react-native-toast-message`:

```typescript
// ✅ Correct for mobile
import Toast from 'react-native-toast-message'

Toast.show({ text1: 'Success message' })
Toast.show({ text1: 'Error message', type: 'error' })

// ❌ Wrong - this is web only
import { toast } from 'components/base/Toast'
toast('Success', 'Message')
```

## Icons

Mobile uses specific SVG component imports, not a generic Icon component:

```typescript
// ✅ Correct for mobile
import EditIcon from 'components/svgs/EditIcon'
import RemoveIcon from 'components/svgs/RemoveIcon'
import IconButton from 'components/IconButton'

<IconButton icon={<EditIcon />} onPress={handleEdit} />
<IconButton icon={<RemoveIcon />} onPress={handleDelete} />

// ❌ Wrong - this is web only
import Icon from 'project/Icon'
<Icon name='edit' fill='primary' />
```

## Confirm Dialogs

Mobile uses Alert or the utility function:

```typescript
// ✅ Correct for mobile
import openConfirm from 'components/utility-components/openConfirm'

openConfirm(
  'Delete Item',
  'Are you sure you want to delete this item?',
  () => handleDelete(),
)

// ❌ Wrong - this is web only
import { openConfirm } from 'components/base/Modal'
openConfirm('Title', <JSXContent />, callback)
```

## Component Naming

Follow existing mobile patterns:

```typescript
// Mobile components in mobile/app/components/
- MailTable.tsx (not MailList)
- TeamTable.tsx
- WhatsAppTable.tsx
- CreateEditNumber.tsx (modal for creating/editing)
- Custom modals use CustomModal component
```

## Modal-Based CRUD Pattern

For list components with create/edit capabilities, use a single modal for both operations:

```typescript
import { useState } from 'react'
import CreateEditModal from './CreateEditModal'

const MyTable: FC = () => {
  const [modalOpen, setModalOpen] = useState(false)
  const [editing, setEditing] = useState<ItemType | null>(null)

  const handleEdit = (item: ItemType) => {
    setEditing(item)
    setModalOpen(true)
  }

  const handleCreate = () => {
    setEditing(null)  // null = create mode
    setModalOpen(true)
  }

  return (
    <>
      <Button onPress={handleCreate}>Add Item</Button>

      {items?.map((item) => (
        <View key={item.id}>
          {!item.cancelled_on && (
            <IconButton
              onPress={() => handleEdit(item)}
              icon={<EditIcon />}
            />
          )}
        </View>
      ))}

      <CreateEditModal
        isOpen={modalOpen}
        onClose={() => setModalOpen(false)}
        initial={editing}  // null for create, data for edit
      />
    </>
  )
}
```

**Modal component pattern:**
```typescript
type Props = {
  isOpen: boolean
  onClose: () => void
  initial?: ItemType | null  // null/undefined = create, data = edit
  onSuccess?: () => void
}

const CreateEditModal: FC<Props> = ({ isOpen, onClose, initial }) => {
  const [createItem] = useCreateItemMutation()
  const [updateItem] = useUpdateItemMutation()

  const [form, setForm] = useState({
    field1: initial?.field1 || '',
    field2: initial?.field2 || '',
  })

  // Reset form when modal opens
  useEffect(() => {
    if (isOpen && initial) {
      setForm({ field1: initial.field1, field2: initial.field2 })
    } else if (isOpen && !initial) {
      setForm({ field1: '', field2: '' })
    }
  }, [isOpen, initial])

  const handleSubmit = async () => {
    if (initial) {
      await updateItem({ id: initial.id, ...form })
    } else {
      await createItem(form)
    }
    onClose()
  }

  return (
    <CustomModal
      visible={isOpen}
      onDismissPress={onClose}
      title={initial ? 'Edit Item' : 'Create Item'}
    >
      {/* form fields */}
    </CustomModal>
  )
}
```

**Key principles:**
- Single modal handles both create and edit
- `initial` prop determines mode (null = create, data = edit)
- Reset form state when modal opens
- Different mutation based on mode
- Button text changes based on mode
